# 类视图与中间件

## 1.函数视图

> 以函数的方式定义的视图称为函数视图，即我们常说的**视图函数**
> **但是:**视图函数遭遇不同方式分别请求( 例如 get 和 post ),并且需要做不同处理时, 我们如果在一个函数中编写不同的业务逻辑, 代码可读性和复用性都不好.

```
from django.http import HttpResponse
# 创建视图函数indexview
def indexview(request):
    if request.method == 'GET':# 获取请求方法，判断是GET/POST请求
        return HttpResponse('indexview get func') # 根据不同的请求方式,做不同的操作处理:
    else:
        return HttpResponse('indexview post func') # 根据不同的请求方式,做不同的操作处理:
```

> 虽然可以完成根据不同的请求进行不同处理的目的, 但是我们这样没有做到分离处理, get和post的处理方式还是放在一个视图函数内部的, 而且也不利于我们后面内容的扩展



## 2.类视图

### 2.1定义类视图

##### 2.1.1定义类视图, 且类视图继承自View

> 使用: `from django.views.generic import View`
> 或者是: `from django.views.generic.base import View`
##### 2.1.2定义路由
> 路由的第二个参数需要是一个函数, 所以我们会调用系统的 as_view() 方法:

 ```
 urlpatterns = [
   # 类视图：注册
   url(r'^register/$',views.RegisterView.as_view()),
   ]
 ```

##### 2.1.3视图代码实现
**使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义。**
> 如下所示:

```

from django.views.generic import View        #导入类视图的父类View
class RegisterView(View):
    """类视图：处理注册"""
    def get(self, request):
        """处理GET请求，返回注册页面"""
        return render(request, 'register.html')
    def post(self, request):
        """处理POST请求，实现注册逻辑"""
        return HttpResponse('这里实现注册逻辑')
```

但是这样写完还不行, 因为我们还需要定义路由部分:

```
urlpatterns = [
    # 注意: 
    # url(路径, 执行的函数)
    # url的第二个参数需要是一个函数
    # 我们这里如果传入: views.RegisterView 会发现这个是一个类, 不是一个函数,
    # 所以我们需要调用系统给我们提供的 as_view() 方法
    url(r'^registerview/$', views.RegisterView.as_view())
]
```
**注意:**
> 如果我们在类视图函数中没有定义方法, 但是我们请求了. 会报405找不到请求方法的错误.
> 例如: 类视图中没有定义Get方法, 但是我们使用Get方法进行了请求, 那么会报405的错误: 找不到对应的请求方法.
> 在类视图中定义的 Get 或者是 POST 都是对象方法, 第一个参数都是self.
> 第二个参数一般情况下都是 request对象. 其他的参数依次往后面写就可以.
> 我们在使用类视图的时候, 需要在路由位置进行设置, 设置的第二个参数需要是一个函数, 所以我们这里调用了类以后, 后面需要调用 as_view( ) 函数.



##  3. 类视图原理

> 为什么我们定义url的时候, 调用 as_view() 函数,就可以达到结果, 如果不调用就会报错.
> 到底 as_view() 帮助我们干了什么了?
> 我们下面来研究一下:

```
    @classonlymethod
    def as_view(cls, **initkwargs):

        ...省略代码...

        def view(request, *args, **kwargs):
            - 这里的cls是as_view这个函数接收的第一个参数,也就是调用当前函数的类.
            
            self = cls(**initkwargs)
            - 得到调用的类了之后, 创建类的对象: self
            
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
                
            - 给当前这个类,添加对应的属性, 如下所示: 
            self.request = request
            self.args = args
            self.kwargs = kwargs
            
            return self.dispatch(request, *args, **kwargs)
            - 调用dispatch方法，按照不同请求方式调用不同请求方法

        ...省略代码...

        - 返回真正的函数视图
        return view



    def dispatch(self, request, *args, **kwargs):
    - dispatch本身是分发的意思,这里指的是函数的名字.
    
        
        if request.method.lower() in self.http_method_names:
            - self.http_method_names指的是我们的类视图中,对象方法的名字
        	- 这里把所有方法的名字都存放在了http_methods_names中
        	- 我们会把当前请求的方式转为小写,然后判断是否在列表中存在.
        		- ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace']
            - 如果在里面, 则进入这里
            - 这里的getattr作用是获取当前对象的属性.
            - 下面的参数为: 
            - self :  类视图对象
            - request.method.lower() : 请求方法的小写. 例如: 'get' 或 'post'
            - http_method_not_allowed : 后续处理方式(不允许请求)
            
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
            - 根据类视图对象, 获取当前类视图中对应名称的方法
            - 如果获取到, 则把方法返回给handle, 否则不允许访问.
            
            
        else:
        	handler = self.http_method_not_allowed
            - 如果类视图中如果没有的话, 则进入这里, 表明不允许进行请求.
            - 我们会把不允许请求这个字段返回给handle.
            
            
        return handler(request, *args, **kwargs)
        - 最终返回handle(handle里面要么包含可以访问的方法, 要么就是不允许访问的字段)
        
        
返回的函数一层一层返回到路由中views.RegisterView.as_view()这个外围,当做客户端访问执行的函数视图.
```

 











